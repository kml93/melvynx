Hello et bienvenue dans l'exercice 12.

On va cr√©er un component `Dialog` au niveau des librairies comme [RadixUI](https://www.radix-ui.com/) !

Autant te dire que tu vas **apprendre √©norm√©ment** de choses sur React, l'accessibilit√© et la gestion de l'√©tat.

## Partie 1 : Contexte

Si tu regardes notre code actuel, tu verras qu'il n'est pas flexible.

Il est compliqu√© de facilement changer le style du bouton pour fermer le dialog et la syntaxe est compliqu√©e, pleine de props.

Heureusement, on a un super outil pour r√©soudre ce probl√®me :

- `useContext` !

Il va nous permettre de cr√©er des components composables qui vont partager le m√™me √©tat tout en √©tant super flexibles.

Le but va √™tre de cr√©er 4 components :

- `Dialog` : le component principal qui va g√©rer l'√©tat du dialog (le context)
- `DialogTrigger` : le component qui va ouvrir le dialog
- `DialogContent` : le component qui va contenir le contenu du dialog
- `DialogClose` : le component qui va fermer le dialog

Tu as toutes les indications avec les √©mojis pour savoir quel component tu dois cr√©er.

- Ce component est inspir√© de [Radix Dialog](https://www.radix-ui.com/primitives/docs/components/dialog), n'h√©site pas √† aller voir la d√©mo pour comprendre ce qui se passe.

Voici comment on va utiliser ton code au r√©sultat de cette partie :

```jsx
export default function App() {
  return (
    <Dialog>
      <DialogTrigger>Open dialog</DialogTrigger>
      <DialogContent>
        <p>What is your name?</p>

        <label className="input input-bordered flex items-center gap-2">
          <User2 scale={16} />
          <input type="text" className="grow" placeholder="Username" />
        </label>
        <div className="flex gap-2">
          <DialogClose>Close</DialogClose>
          <button className="btn btn-primary">Submit</button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

## Partie 2 : Customisation des boutons

Pour l'instant, notre component `DialogTrigger` et `DialogClose` sont tr√®s peu flexibles. Ce sont des boutons hardcod√©s et on ne peut pas les remplacer par ce qu'on veut.

Ta t√¢che va √™tre de venir autoriser l'utilisateur √† utiliser ton `DialogTrigger` de cette mani√®re :

```jsx
<DialogTrigger>
  <button className="btn btn-primary btn-lg">Open Dialog Now!</button>
</DialogTrigger>
```

La m√™me chose pour le close button :

```jsx
<DialogClose>
  <button className="absolute right-4 top-4 flex size-6 items-center justify-center rounded-lg bg-base-100">
    <X size={12} />
  </button>
</DialogClose>
```

√áa va nous permettre d'√™tre beaucoup plus flexibles.

Pour faire √ßa tu vas avoir besoin d'un nouvel outil : [üìö `cloneElement` de React](https://react.dev/reference/react/cloneElement).

Il te permet de `cloner` un children et de lui "injecter" des props.

```jsx
import { cloneElement } from "react";

// ...
const clonedElement = cloneElement(
  <Row title="Cabbage">Hello</Row>,
  { isHighlighted: true },
  "Goodbye"
);

console.log(clonedElement); // <Row title="Cabbage" isHighlighted={true}>Goodbye</Row>
```

Tu vas donc pouvoir l'utiliser un peu comme √ßa :

```jsx
const YourComponents = ({ children }) => {
  return cloneElement(children, { className: "text-red-500" });
};
```

Ici j'ai cr√©√© un component qui va cloner le children et lui ajouter une classe `text-red-500`.

Tu peux aussi rajouter des events :

```jsx
const YourComponents = ({ children }) => {
  return cloneElement(children, { onClick: () => alert("Hello") });
};
```

Ta t√¢che est de faire √ßa pour le component `DialogTrigger` et `DialogClose`.

‚ö†Ô∏è Il faut que tu le fasses que si `children` n'est PAS de type `string`.

## Partie 3 : Accessibilit√©

> <h4>üòµ‚Äçüí´ Exercice avanc√© !</h4>
>
> Je te propose ici un exercice avanc√© qui va te permettre de mieux comprendre le web et de pratiquer. Si tu as des probl√®mes pour le terminer, regarde la vid√©o solution.

Il y a 4 probl√®mes actuels dans notre code :

1. Il manque des `aria` pour les composants
2. Il manque la feature de "Escape" pour fermer le dialog
3. Il manque la feature de "Click Outside" pour fermer le dialog
4. Il manque la feature de "Focus Trap" pour emp√™cher l'utilisateur de sortir du dialog

### 1. Ajouter les `aria`

Tu vas devoir ajouter les attributs `aria` suivants :

- `role="dialog"` sur le `Dialog`
- `aria-modal="true"` sur le `Dialog`

Il faudrait en rajouter d'autres mais ce sont les plus importants.

### 2. Feature de "Escape"

Il faut que tu cr√©es le fameux hook `useEventListener` qu'on a fait dans le workshop `useState` pour venir √©couter l'√©v√©nement `keydown` et fermer le dialog si l'utilisateur appuie sur la touche `Escape`.

### 3. Feature de "Click Outside"

Tu vas devoir cr√©er un hook un peu compliqu√©. Le but est de venir √©couter les `clicks` de la page enti√®re et si un `click` se fait en dehors du dialog, il faut fermer le dialog.

Il faut que tu √©coutes les events `mousedown` et `touchstart` et si un `click` est fait en dehors du dialog, tu vas fermer le dialog.

Pour le v√©rifier il va falloir rajouter une `ref` sur l'√©l√©ment du DialogContent :

```jsx
const DialogContent = ({ children, className = "" }) => {
  const { open, setOpen } = useDialogContext();
  const ref = useRef(null); // Cr√©er une ref
  useClickOutside(ref, () => setOpen(false));

  if (!open) return null;

  return (
    <div
      role="dialog"
      aria-modal="true"
      className="fixed inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm animate-in fade-in-50"
    >
      <div
        ref={ref} // Ici
        className={cn(
          "card w-96 bg-base-200 shadow-xl animate-in fade-in-50 slide-in-from-bottom-3",
          className
        )}
      >
        <div className="card-body">{children}</div>
      </div>
    </div>
  );
};
```

Ensuite le `useClickOutside` va ressembler √† √ßa :

```jsx
const useClickOutside = (ref, handler) => {
  // Si le click est fait en dehors du ref, on appelle le handler
};
```

Pour v√©rifier si un √©l√©ment est en dehors d'un autre √©l√©ment, tu peux utiliser la m√©thode `contains` :

```jsx
const listenerDemo = (event) => {
  const target = event.target; // l'√©l√©ment qui a √©t√© cliqu√©

  if (ref.current.contains(target)) {
    // Si l'√©l√©ment cliqu√© est dans le ref, on ne fait rien
    return;
  }

  // Sinon on appelle le handler
};
```

Voil√† je te laisse pour mettre √ßa tout ensemble.

### 4. Feature de "Focus Trap" (Difficile)

Il va falloir venir rajouter un hook `useFocusTrap(ref, isEnable)` qui va venir emp√™cher l'utilisateur de sortir du dialog.

Dans la derni√®re vid√©o je t'ai montr√© ce probl√®me en te montrant que notre focus va venir "sortir" du Dialog alors qu'on veut qu'il reste √† l'int√©rieur !

Pour √ßa il va falloir :

1. R√©cup√©rer tous les √©l√©ments focusables

```js
const getFocusableElements = (ref) =>
  Array.from(
    ref.current.querySelectorAll(
      'a[href], button, textarea, input[type="text"], input[type="radio"], input[type="checkbox"], select'
    )
  );
```

2. D√©finir le prochain √©l√©ment focusable

Pour √ßa tu peux utiliser `document.activeElement`. Il correspond √† l'√©l√©ment qui est focus **actuellement**.

On va vouloir r√©cup√©rer l'index de cet √©l√©ment dans le tableau des √©l√©ments focusables.

Puis on va ajouter `-1` si `event.shiftKey` est `true` et `+1` si `event.shiftKey` est `false`.

Pourquoi ? Car quand on utilise `Shift + Tab` on veut aller √† l'√©l√©ment pr√©c√©dent et quand on utilise `Tab` on veut aller √† l'√©l√©ment suivant.

Une fois fait, tu vas pouvoir v√©rifier que la valeur qu'on a trouv√©e est bien dans le tableau des √©l√©ments focusables.

Si c'est le cas, on ne fait rien.

Si ce n'est pas le cas, on va venir r√©cup√©rer le premier ou le dernier √©l√©ment focusable.

- Si l'index est inf√©rieur √† 0, on va prendre le dernier √©l√©ment focusable, c'est que l'utilisateur essaie de retourner en arri√®re alors qu'il est d√©j√† au d√©but.
- Sinon, on va prendre le premier √©l√©ment focusable, √ßa voudrait dire que l'utilisateur essaie d'aller en avant alors qu'il est d√©j√† √† la fin.

Une fois r√©cup√©r√©, on va utiliser `element.focus()` pour forcer le focus sur l'√©l√©ment et `event.preventDefault()` pour emp√™cher le comportement par d√©faut du navigateur.

3. Focus le premier √©l√©ment par d√©faut

On va rajouter un autre `useEffect` qui va faire que si `open` est √† `true`, on va venir focus le premier √©l√©ment focusable.

Tu peux utiliser la m√™me m√©thode (`getFocusableElements`) que pour r√©cup√©rer les √©l√©ments focusables.

> <h4>ü§Ø Ne te prends pas trop la t√™te !</h4>
>
> Si tu as du mal √† avancer, fais une pause, et regarde la vid√©o solution si besoin.

## Remerciements

- Merci √† [Radix](https://www.radix-ui.com/) de me rendre soucieux de tous les d√©tails de l'accessibilit√©.
- Merci √† [Tinloof](https://tinloof.com/blog/how-to-create-an-accessible-react-modal) qui a fait un article qui met en avant les points importants √† faire. Son code ne marche pas, mais il a essay√©.
