# Todo list

Que serait une formation sans une todo list ?

Dans cet exercice, on va cr√©er la fameuse todo list pour en apprendre plus sur les **states immuables** et comment √ßa fonctionne.

## Part 1 : Base

La premi√®re partie va se concentrer sur la plus √©l√©mentaire des features : **l'ajout**.

Pour g√©rer l'ajout, tu vas devoir cr√©er une m√©thode qui cr√©e une nouvelle todo et l'ajoute √† la liste.

Une todo a ce format :

```json
{
  "id": 1222919191,
  "text": "Faire les courses",
  "completed": false
}
```

L'`id` est g√©n√©r√© avec `Date.now()`.

Pour ajouter un √©l√©ment dans un state immuable, tu vas devoir utiliser la m√©thode `setTodos` de `useState`.

Mais tu ne peux pas faire √ßa :

```js
todos.push(newTodo);
```

Le state ne va pas √™tre mis √† jour. Pour informer React que le state a chang√©, tu dois cr√©er une nouvelle liste avec le nouvel √©l√©ment et utiliser `setTodos` pour mettre √† jour le state.

```js
// 1. Ajouter un nouvel √©l√©ment
const newTodos = [...todos, newTodo];
// 2. Mettre √† jour le state
setTodos(newTodos);
```

Ceci fonctionne car en faisant `[...todos]`, on cr√©e une nouvelle liste avec les √©l√©ments de `todos` et en ajoutant `newTodo`, on cr√©e une nouvelle liste avec un √©l√©ment en plus.

Je te laisse faire l'exercice avec l'aide de ü¶Å !

Et oublie pas de rajouter un "empty state" si il n'y a pas de todos.

## Part 2 : Toggle

Dans le `TodoItem`, il y a un bouton pour marquer une todo comme compl√©t√©e. Tu vas devoir cr√©er une m√©thode qui change le statut de la todo.

Pour trouver le `todo` dans la liste, on va utiliser l'`id` de la todo.

Ta m√©thode ressemblera √† √ßa :

```js
const updateTodo = (id) => {
  // Utilise .map pour cr√©er une nouvelle liste avec le bon √©l√©ment modifi√©
};
```

Avec le state synchronis√©, tu vas pouvoir ajouter le style `line-through` sur le texte si la `todo` est `completed` !

## Part 3 : Remove

On va ajouter un bouton delete √† c√¥t√© de notre todo avec ce code :

```jsx
import { Plus, Trash } from "lucide-react";

// ...

<button className="btn btn-ghost">
  <Trash size={16} />
</button>;
```

Lors du clic, il va appeler la m√©thode `removeTodo` avec l'`id` de la todo.

Une fois fait, tu vas devoir cr√©er la m√©thode `removeTodo` qui va supprimer la todo de la liste.

```js
const removeTodo = (id) => {
  // Utilise .filter pour cr√©er une nouvelle liste sans l'√©l√©ment √† supprimer
};
```

## Part 4 : Custom hooks

On commence √† avoir **beaucoup** de m√©thodes et notre composant `Todos` devient trop long.

La magie avec React, c'est qu'on peut extraire des morceaux de logique dans des **custom hooks**.

Les **custom hooks** sont des hooks qu'on cr√©e nous-m√™me. Il y a les hooks React :

- `useState`
- `useEffect`
- `useContext`
- etc...

Et nos custom hooks.

Pour cr√©er un custom hook, il faut :

- Cr√©er une fonction qui commence par `use`
- Utiliser cette fonction **dans un composant React**

Cette fonction peut retourner tout ce qu'on veut :

```js
const useToggle = (initialValue = false) => {
  const [value, setValue] = useState(initialValue);

  const toggle = () => setValue(!value);

  // Ici je retourne `value` et `toggle` dans un objet
  return { value, toggle };
};

const Component = () => {
  // Je peux ensuite d√©structurer les valeurs
  // pour les utiliser dans mon composant
  const { value, toggle } = useToggle();

  return <button onClick={toggle}>{value ? "ON" : "OFF"}</button>;
};
```

Tu vas pouvoir cr√©er un custom hook qui retourne :

- `addTodo(text)`
- `updateTodo(id)`
- `removeTodo(id)`
- `todos`

Tu pourras ensuite utiliser ce custom hook dans ton composant `Todos` pour rendre le code plus lisible.

## Part 5 : Mise √† jour du texte (Difficile)

Attention, cette partie est compliqu√©e volontairement.

J'ai envie de rajouter une feature.

Quand **je clique sur le texte d'un todo**, je veux que celui-ci devienne un input pour pouvoir le modifier.

Pour √ßa, il va falloir ajouter pas mal de choses.

1. Cr√©er un state `editingId` qui va contenir l'`id` de la todo en cours d'√©dition.
2. Modifier la m√©thode `updateTodo` pour qu'elle prenne en param√®tre l'`id` ET le `newTodo`.

- `newTodo` repr√©sente un objet qui peut contenir la cl√© `text` ou `completed`.
- Ne modifie que les √©l√©ments qui sont pass√©s en param√®tre, pour √ßa tu peux utiliser cette syntaxe :

```js
{
  // on garde les anciennes valeurs
  ...todo,
  // on remplace les valeurs si elles sont pass√©es en param√®tre
  // ?? = si la valeur est null ou undefined, on garde la valeur de todo
  completed: newTodo.completed ?? todo.completed,
  text: newTodo.text ?? todo.text,
}
```

- Modifier les utilisations de `updateTodo`, notamment sur la checkbox pour qu'elle prenne en param√®tre un objet avec la cl√© `completed` qui est l'inverse de `todo.completed`.

2. Modifier l'√©l√©ment todo

- Il faut remplacer le `label` par un `div` pour √©viter de toggler l'√©dition √† chaque clic.
- Il faut utiliser un ternaire pour afficher un `input` si l'`id` est √©gal √† `editingId`.
- Lors du `onChange` de l'`input`, il faut mettre √† jour le `newTodo` avec le nouveau texte (avec `updateTodo`).
- Lors du `onBlur` (quand on sort de l'`input`), il faut mettre √† jour l'`editingId` √† `null`.
- Tu peux finalement modifier les classes de la `div` qui contient la classe `input` pour afficher une classe quand celui-ci est en train d'√™tre modifi√© :

```js
clsx("input flex flex-1 items-center gap-2", {
  "input-bordered": editingId === todo.id,
});
```

Si tu n'as pas r√©ussi : aucun souci. Prends un maximum de 10 minutes pour faire cet exercice, puis regarde la vid√©o solution.

Tu as remarqu√© que notre code √©tait moche ?

Tr√®s tr√®s moche.

C'est parce qu'on n'utilise pas les composants. On va utiliser les composants pour g√©rer l'√©dition de la todo ainsi que le formulaire et rendre notre code bien plus beau.

### Attention : probl√®me commun

Dans les exercices pr√©c√©dents, on a cr√©√© une m√©thode `updateTodo`. Il faut faire attention √† ce que cette m√©thode prenne bien deux param√®tres :

- `id` : l'identifiant de la todo √† modifier
- `newTodo` : un objet contenant les nouvelles valeurs de la todo

Ensuite, tu vas devoir merger l'ancien `todo` au `nouveau todo` en utilisant la m√©thode `map`. Tu peux utiliser la syntaxe suivante :

```js
{
  ...currTodo,
  ...newTodo
}
```

De cette mani√®re, si `newTodo` est √©gal √† `{ completed: false }`, il va venir modifier la valeur de `completed` et garder les anciennes valeurs.

## Part 6 : Components

Nos composants sont un peu bord√©liques. On a beaucoup de logique et il serait int√©ressant de refactoriser notre composant `Todos` en 2 autres composants :

- `Todos` : qui va afficher la liste des todos et le formulaire.
- `TodoItem` : qui va afficher une todo et qui va prendre en props les m√©thodes `updateTodo` et `removeTodo`.
- `TodoForm` : qui va prendre en props la m√©thode `addTodo`.

Je te laisse faire ceci afin d'avoir un code parfait !

## Ce qu'on a appris

- √Ä utiliser les states immuables.
- √Ä ajouter, modifier, supprimer des √©l√©ments dans une liste.
- √Ä cr√©er des custom hooks.
- √Ä refactoriser un composant en plusieurs composants.
- Comprendre l'importance de mettre le state au bon endroit.
