Dans cet exercice, on va s'amuser avec des **faits sur des chats üò∏ !**

Pour √ßa, on va utiliser l'API [Cat Facts](https://catfact.ninja/fact) qui nous donne des faits sur des chats.

On va utiliser **3 m√©thodes** pour g√©rer les donn√©es de l'API :

1. Utiliser `useEffect` + `fetch`
2. Utiliser `useSWR` + `fetch`
3. Utiliser `use` + `Suspense` + `ErrorBoundary` + `fetch`

Pour chaque app, on voudra g√©rer tous les cas :

1. L'√©tat de chargement
2. L'√©tat d'erreur
3. L'√©tat o√π tout se passe bien

## Partie 1 : Utiliser `useEffect` + `fetch`

Le but est d'utiliser un `useEffect` avec √† l'int√©rieur un `fetch` pour r√©cup√©rer les donn√©es de `https://catfact.ninja/fact` !

Il retourne ceci :

```json
{
  "fact": "In just seven years, a single pair of cats and their offspring could produce a staggering total of 420,000 kittens.",
  "length": 115
}
```

Pour faire un fetch en JavaScript, tu peux regarder la documentation de [fetch MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

## Partie 2 : Utiliser `useSWR` + `fetch`

[SWR](https://swr.vercel.app/) est la librairie la plus simple qui te permet de fetch une API rapidement et efficacement.

Tu vas pouvoir **refactor** notre code pr√©c√©dent en utilisant `useSWR` √† la place de `useEffect` + `fetch`.

Dans le [Getting started](https://swr.vercel.app/docs/getting-started), tu as tout ce qu'il faut.

Tu as juste besoin du fetch :

```js
// @ts-ignore
const fetcher = (...args) => fetch(...args).then((res) => res.json());
```

N'oublie pas le `@ts-ignore` pour √©viter les erreurs de TypeScript.

Tu verras qu'avec `useSWR`, tu vas pouvoir supprimer l'int√©gralit√© du code qu'on a fait pr√©c√©demment en gardant exactement les m√™mes fonctionnalit√©s.

## Partie 3 : Utiliser `use` + `Suspense` + `ErrorBoundary` + `fetch`

√áa, c'est la nouvelle m√©thode.

Il y a 3 nouvelles choses ici.

### `use`

Ce hook est un peu sp√©cial car depuis React 19, il est devenu stable et te permet de venir "attendre" un r√©sultat asynchrone.

```js
const Fact = () => {
  const fact = use(fetchFact());
  return <div>{fact}</div>;
};
```

On va avoir √† peu pr√®s ce code et quand tu fais √ßa, Fact vient throw une promesse qui peut √™tre catch par `Suspense` √† l'usage.

### `Suspense`

C'est un peu le composant magique de React qui permet d'afficher un √©tat de chargement quand il y a besoin.

On peut l'utiliser dans plusieurs cas mais ici, il faut savoir qu'il vient "catch" les promesses throw par `use`.

Une fois fait, il r√©cup√®re le r√©sultat et l'affiche.

Pour l'utiliser :

```js
const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <Fact />
  </Suspense>
);
```

### `ErrorBoundary`

C'est un composant custom que tu peux retrouver dans [ErrorBoundaries.jsx](src/utils/ErrorBoundaries.jsx) qui permet de catch les erreurs dans un composant.

Dans le cas o√π notre promesse vient throw une erreur, `ErrorBoundary` va catch l'erreur et afficher un message d'erreur.

### M√©lange tout !

La diff√©rence avec ce qu'on a fait avant, c'est que maintenant notre composant va uniquement ressembler √† l'affichage.

Pour √ßa, il faut d√©placer toute la logique asynchrone dans une m√©thode `fetchFact` qui va √™tre appel√©e par `use`.

```js
const fetchFact = async () => {};

const json = use(fetchFact());
```

L'avantage, c'est que `use` retourne directement le **r√©sultat**. On n'a donc pas besoin de state d'erreur, etc. dans le composant mais dans celui qui affiche `Fact` !

Si c'est trop compliqu√©, ne perds pas de temps et va voir la vid√©o solution.
